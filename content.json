{"pages":[{"title":"about","text":"ABOUT","link":"/blog/about/index.html"}],"posts":[{"title":"博客搭建记录","text":"采用 github Pages + Hexo 搭建 hexo命令 123hexo d -ghexo new post 配置 Tags和category url - 主题ICARUS https://ppoffice.github.io/hexo-theme-icarus/ Hexo Icarus主题配置完全手册 About页面 目前仍不知怎么配置公式渲染测试 This is inline expression: $ax^2+bx+c&gt;0$. This is a block expression:$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ Or use $LaTeX$ environment: \\begin{equation} A = \\begin{bmatrix} a & b \\\\ c & c \\end{bmatrix} \\end{equation}","link":"/blog/Blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"title":"2022实训记录","text":"vue3+vite+tailwindCSS","link":"/blog/frontend/vue/yxhyRecord/"},{"title":"osLabPKE","text":"配环境Ubuntu 20.04 工程文件夹: /home/lkr/oslab 下载交叉编译器和执行环境解压 tar xf riscv64-elf-gcc-20210923.tgz 解压完成后，将在当前目录产生名为riscv64-elf-gcc的目录，该目录下包含RISC-V交叉编译器以及spike模拟器。 设置环境变量 12export RISCV=$PWD/riscv64-elf-gccexport PATH=$PATH:$RISCV/bin 将以上两个export命令，加入到/.bashrc，/.profile或 /etc/profile文件的末尾（注意替换$PWD环境变量）。 12pwd # 查看当前目录 这样，每次重新启动（并打开终端程序）后，系统会自动设置这两个环境变量，而不用每次都要手动输入以上命令。 下代码1234git clone https://gitee.com/hustos/riscv-pke.git# 查看文件结构cd riscv-pketree -L 3 环境验证 12makespike ./obj/riscv-pke ./obj/app_helloworld Lab1 系统调用sudo开启vscode，不安全但是方便 1sudo code --no-sandbox --user-data-dir=&quot;~/.vscode&quot; 失败 lab1_1做完执行 12make clean;makespike ./obj/riscv-pke ./obj/app_helloworld lab1_2 异常处理1234567# 切换到 lab1_2 # 继承 lab1_1的答案git checkout lab1_2_exceptiongit merge lab1_1_syscall -m &quot;continue to work on lab1_2&quot;# 重新构造 # 运行构造结果make clean; makespike ./obj/riscv-pke ./obj/app_illegal_instruction 做完提交 1git commit -a -m &quot;my work on lab1_2 is done.&quot; lab1_3123456# 切换到lab1_3git checkout lab1_3_irqgit merge lab1_2_exception -m &quot;continue to work on lab1_3&quot;make clean; makespike ./obj/riscv-pke ./obj/app_long_loop 做完提交 1git commit -a -m &quot;my work on lab1_3 is done.&quot; lab2lab2_1123456# 切换到lab2_1git checkout lab2_1_pagetablegit merge lab1_3_irq -m &quot;continue to work on lab2_1&quot;make clean; makespike ./obj/riscv-pke ./obj/app_helloworld_no_lds 做完提交 1git commit -a -m &quot;my work on lab2_1 is done.&quot; lab2_2123456# 切换到lab2_2git checkout lab2_2_allocatepagegit merge lab2_1_pagetable -m &quot;continue to work on lab2_2&quot;make clean; makespike ./obj/riscv-pke ./obj/app_naive_malloc 做完提交 1git commit -a -m &quot;my work on lab2_2 is done.&quot; lab2_3123456# 切换到lab2_3git checkout lab2_3_pagefaultgit merge lab2_2_allocatepage -m &quot;continue to work on lab2_3&quot;make clean; makespike ./obj/riscv-pke ./obj/app_sum_sequence 做完提交 1git commit -a -m &quot;my work on lab2_3 is done.&quot; Lab3 进程管理Lab3_1 进程创建12345git checkout lab3_1_forkgit merge lab2_3_pagefault -m &quot;continue to work on lab3_1&quot;make clean; makespike ./obj/riscv-pke ./obj/app_naive_fork 分析子进程child的代码段CODE_SEGEMENT逻辑地址映射到父进程代码段的物理地址 12345678910111213int map_pages(pagetable_t page_dir, uint64 va, uint64 size, uint64 pa, int perm) { uint64 first, last; pte_t *pte; for (first = ROUNDDOWN(va, PGSIZE), last = ROUNDDOWN(va + size - 1, PGSIZE); first &lt;= last; first += PGSIZE, pa += PGSIZE) { if ((pte = page_walk(page_dir, first, 1)) == 0) return -1; if (*pte &amp; PTE_V) panic(&quot;map_pages fails on mapping va (0x%lx) to pa (0x%lx)&quot;, first, pa); *pte = PA2PTE(pa) | perm | PTE_V; } return 0;} user_vm_map是对map_pages的封装 123456789101112131415161718192021222324252627282930313233343536pte_t *page_walk(pagetable_t page_dir, uint64 va, int alloc) { if (va &gt;= MAXVA) panic(&quot;page_walk&quot;); // starting from the page directory pagetable_t pt = page_dir; // traverse from page directory to page table. // as we use risc-v sv39 paging scheme, there will be 3 layers: page dir, // page medium dir, and page table. for (int level = 2; level &gt; 0; level--) { // macro &quot;PX&quot; gets the PTE index in page table of current level // &quot;pte&quot; points to the entry of current level pte_t *pte = pt + PX(level, va); // now, we need to know if above pte is valid (established mapping to phyiscal page) // or not. if (*pte &amp; PTE_V) { //PTE valid // phisical address of pagetable of next level pt = (pagetable_t)PTE2PA(*pte); } else { //PTE invalid (not exist). // allocate a page (to be the new pagetable), if alloc == 1 if( alloc &amp;&amp; ((pt = (pte_t *)alloc_page(1)) != 0) ){ memset(pt, 0, PGSIZE); // writes the physical address of newly allocated page to pte, to establish the // page table tree. *pte = PA2PTE(pt) | PTE_V; }else //returns NULL, if alloc == 0, or no more physical page remains return 0; } } // return a PTE which contains phisical address of a page return pt + PX(0, va);} 该函数的第一个输入参数page_dir为根目录所在物理页面的首地址，第二个参数va为所要查找（walk）的逻辑地址，第三个参数实际上是一个bool类型：当它为1时，如果它所要查找的逻辑地址并未建立与物理地址的映射（图4.1中的Page Medium Directory）不存在，则通过分配内存空间建立从根目录到页表的完整映射，并最终返回va所对应的页表项；当它为0时，如果它所要查找的逻辑地址并未建立与物理地址的映射，则返回NULL，否则返回va所对应的页表项。 看代码发现lab3-1新增了个打印debug的函数print_proc_vmspace 打印调试一下可以看到父子进程的代码段 pa是通过lookup利用进程的pagetable和mappedinfo的va得到的。 child的va在mapping之后才复制，那我们只需要修改他的pagetable即可，将代码段相关的pagetable修改 显然要用到lab2提到的user_vm_map ，逐个分析参数，第一个pagetable是被修改的，应该传入子线程的pagetable，va用父线程，因为后面 register vm 的时候将子进程的va赋值为父进程的va。pa显然也是父进程的，这里要用到lab2_1写的user_va_to_pa 函数。proctotype的最后一个参数应该是用户态，PGSIZE就是pagesize。 做完交一发 1git commit -a -m &quot;my work on lab3_1 is done.&quot; Lab3_2切换分支12345git checkout lab3_2_yieldgit merge lab3_1_fork -m &quot;continue to work on lab3_2&quot;make clean; makespike ./obj/riscv-pke ./obj/app_yield 分析太水了不分析了 做完交一发 1git commit -a -m &quot;my work on lab3_2 is done.&quot; Lab3_3切换分支12345git checkout lab3_3_rrschedgit merge lab3_2_yield -m &quot;continue to work on lab3_3&quot;make clean; makespike ./obj/riscv-pke ./obj/app_two_long_loops 做完交一发 1git commit -a -m &quot;my work on lab3_3 is DONE!!!&quot; 基础实验完成，待会肝挑战。","link":"/blog/OS/osLabPKE/"}],"tags":[{"name":"record","slug":"record","link":"/blog/tags/record/"},{"name":"Lab","slug":"Lab","link":"/blog/tags/Lab/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/blog/categories/Blog/"},{"name":"frontend","slug":"frontend","link":"/blog/categories/frontend/"},{"name":"vue","slug":"frontend/vue","link":"/blog/categories/frontend/vue/"},{"name":"OS","slug":"OS","link":"/blog/categories/OS/"}]}