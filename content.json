{"pages":[{"title":"about","text":"ABOUT","link":"/blog/about/index.html"}],"posts":[{"title":"博客搭建记录","text":"采用 github Pages + Hexo 搭建 hexo命令 123hexo d -ghexo new post 配置 Tags和category url - 主题ICARUS https://ppoffice.github.io/hexo-theme-icarus/ Hexo Icarus主题配置完全手册 About页面 目前仍不知怎么配置公式渲染测试 This is inline expression: $ax^2+bx+c&gt;0$. This is a block expression:$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ Or use $LaTeX$ environment: \\begin{equation} A = \\begin{bmatrix} a & b \\\\ c & c \\end{bmatrix} \\end{equation}","link":"/blog/Blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"title":"2022实训记录","text":"vue3+vite+tailwindCSS","link":"/blog/frontend/vue/yxhyRecord/"},{"title":"osLabPKE","text":"配环境Ubuntu 20.04 工程文件夹: /home/lkr/oslab 下载交叉编译器和执行环境解压 tar xf riscv64-elf-gcc-20210923.tgz 解压完成后，将在当前目录产生名为riscv64-elf-gcc的目录，该目录下包含RISC-V交叉编译器以及spike模拟器。 设置环境变量 12export RISCV=$PWD/riscv64-elf-gccexport PATH=$PATH:$RISCV/bin 将以上两个export命令，加入到/.bashrc，/.profile或 /etc/profile文件的末尾（注意替换$PWD环境变量）。这样，每次重新启动（并打开终端程序）后，系统会自动设置这两个环境变量，而不用每次都要手动输入以上命令。 下代码1234git clone https://gitee.com/hustos/riscv-pke.git# 查看文件结构cd riscv-pketree -L 3 环境验证 12makespike ./obj/riscv-pke ./obj/app_helloworld Lab1 系统调用sudo开启vscode，不安全但是方便 1sudo code --no-sandbox --user-data-dir=&quot;~/.vscode&quot; 失败 lab1_1Lab3 进程管理Lab3_1 进程创建子进程child的代码段CODE_SEGEMENT逻辑地址映射到父进程代码段的物理地址 12345678910111213int map_pages(pagetable_t page_dir, uint64 va, uint64 size, uint64 pa, int perm) { uint64 first, last; pte_t *pte; for (first = ROUNDDOWN(va, PGSIZE), last = ROUNDDOWN(va + size - 1, PGSIZE); first &lt;= last; first += PGSIZE, pa += PGSIZE) { if ((pte = page_walk(page_dir, first, 1)) == 0) return -1; if (*pte &amp; PTE_V) panic(&quot;map_pages fails on mapping va (0x%lx) to pa (0x%lx)&quot;, first, pa); *pte = PA2PTE(pa) | perm | PTE_V; } return 0;} 123456789101112131415161718192021222324252627282930313233343536pte_t *page_walk(pagetable_t page_dir, uint64 va, int alloc) { if (va &gt;= MAXVA) panic(&quot;page_walk&quot;); // starting from the page directory pagetable_t pt = page_dir; // traverse from page directory to page table. // as we use risc-v sv39 paging scheme, there will be 3 layers: page dir, // page medium dir, and page table. for (int level = 2; level &gt; 0; level--) { // macro &quot;PX&quot; gets the PTE index in page table of current level // &quot;pte&quot; points to the entry of current level pte_t *pte = pt + PX(level, va); // now, we need to know if above pte is valid (established mapping to phyiscal page) // or not. if (*pte &amp; PTE_V) { //PTE valid // phisical address of pagetable of next level pt = (pagetable_t)PTE2PA(*pte); } else { //PTE invalid (not exist). // allocate a page (to be the new pagetable), if alloc == 1 if( alloc &amp;&amp; ((pt = (pte_t *)alloc_page(1)) != 0) ){ memset(pt, 0, PGSIZE); // writes the physical address of newly allocated page to pte, to establish the // page table tree. *pte = PA2PTE(pt) | PTE_V; }else //returns NULL, if alloc == 0, or no more physical page remains return 0; } } // return a PTE which contains phisical address of a page return pt + PX(0, va);} 该函数的第一个输入参数page_dir为根目录所在物理页面的首地址，第二个参数va为所要查找（walk）的逻辑地址，第三个参数实际上是一个bool类型：当它为1时，如果它所要查找的逻辑地址并未建立与物理地址的映射（图4.1中的Page Medium Directory）不存在，则通过分配内存空间建立从根目录到页表的完整映射，并最终返回va所对应的页表项；当它为0时，如果它所要查找的逻辑地址并未建立与物理地址的映射，则返回NULL，否则返回va所对应的页表项。","link":"/blog/OS/osLabPKE/"}],"tags":[{"name":"record","slug":"record","link":"/blog/tags/record/"},{"name":"Lab","slug":"Lab","link":"/blog/tags/Lab/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/blog/categories/Blog/"},{"name":"frontend","slug":"frontend","link":"/blog/categories/frontend/"},{"name":"vue","slug":"frontend/vue","link":"/blog/categories/frontend/vue/"},{"name":"OS","slug":"OS","link":"/blog/categories/OS/"}]}